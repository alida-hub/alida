1. First operator

As a first example of an Alida operator we implement the row or column wise
sum for a 2D array of Doubles.
The class MatrixSum extending ALDOperator features three member variables
holding the input 2D array, an enum to indicate the mode of summation (ROW or COLUMN), and
an 1D array of the sums to be computed and returned by the operator.
Alida requires only to annotate these members with the @Parameter annotation
which declares 
	- the direction (IN, OUT, INOUT), 
	- whether the parameter is required,
	- an optional textual description,
	- and a label used, e.g. in the graphical user interface automatically generated
		to execute the operator.
It is important to add a public standard constructor (without arguments)
to be able to use Java's reflection mechanism.
Finally, the abstract method operate() of ALDOperator has to be overridden
implementing the functionality of the operator.

These are the basic requirements for the operator to be used on the programming level.
An example of this use is included in the example in the next section.

If we further annotate the class with @ALDAOperator(genericExecutionMode=ALDAOperator.ExecutionMode.ALL)
this is all needed to also facilitate 
execution of this operator via a graphical and a command line user interface
automatically generated by Alida.
(Setting level=ALDAOperator.Level.APPLICATION declares this operator an application
which is used in the GUI to control display of available operators.)


1.1 Invocation via a graphical user interface

Alida comes with one single application to execute Alida operators
with a automatically generated graphical user interface which may be
started from command line by
	java de.unihalle.informatik.Alida.tools.ALDOpRunnerGUI

This will pop up a window to choose an operator to execute.
Arranged according to the package structure all operators allows to be executed
via the graphical user interface according to their genericExecutionMode
are displayed.
Initially packages are unfolded up to a predefined depth.
Unfold the demo package, select MatrixSum, and choose the "Configure Operator" button.
This will pop up another window which allows you to configure the input parameters
of the operator.
Important note: After finishing to input the data matrix entering the final matrix elements
you have to select a previous matrix element due to subtle AWT details.
For the enumeration to select the mode Alida has automatically generated
a combo box to allow convenient selections.
If you are finished with the parameter configuration you want to invoke the operator
using the run button.
On completion of MatrixSum the interface will pop up the result window which allows you
to inspect the outcome of the operation.

1.2 Invocation via command line

The command line user interface of Alida allows to invoke all Alida operator
properly annotated to allows generic execution.

You may invoke the matrix summation operator by
	java de.unihalle.informatik.Alida.tools.ALDOpRunner MatrixSum matrix='[[1,2,3],[4,5,6]]' sums=-
which returns as result on standard output
	sums = [6.0,15.0]

Parameter values are specified as name=value pairs.
Alida's syntax for 2D array should be self-explanatory  from this example.
As the mode of summation is not supplied as a parameter its default is used

Note, the command
	java de.unihalle.informatik.Alida.tools.ALDOpRunner MatrixSum matrix='[[1,2,3],[4,5,6]]' 
will return no output as the command line user interface returns only output parameters requested.

The enumeration defined in MatrixSum is supported by the
user interface without further action required as shown in the next example.
This also demonstrates redirection of output
to a file, sums.out in this case.

	java de.unihalle.informatik.Alida.tools.ALDOpRunner MatrixSum matrix='[[1,2,3],[4,5,6]]' summarizeMode=COLUMN sums=@sums.out

Input can be read from file as well:
	java de.unihalle.informatik.Alida.tools.ALDOpRunner MatrixSum matrix=@data sums=-

where the file data contains the string defining the matrix, e.g., [[1,2,3],[4,5,6]]

2. Adding more features to an operator

We now generalize this example to realize not only summation over rows or
columns, but arbitrary summarizing operations.
This shows Alida's feature to allow an operator as parameter of another operator.

2.1 Implementation

First we generalize ALDArraySum to the operator ApplyToMatrix
which also takes a 2D array and an enum indicating the mode of marginalization (ROW or COLUMN).
It takes an additional input parameter which specifies the operation to be applied on each
row or column.

This parameter is itself an Alida operator and of type ALDSummarizeArrayOp
which is implemented as an abstract class.
This abstract operator defines a summarizing operator
which takes a 1D array as input and returns a summarizing scalar.
As this is an abstract class there is no need to override the operate
method, however some getter and setter methods are provided.

Now we add concrete examples of such a summarizing operation, in this case
summation (ALDArraySum), to return the mean (ALDArrayMean), and the minimum (ALDArrayMin).
Each implements the operate method and has to supply a standard constructor.
In this example we add another constructor for convenience.
This operators are declared as operators on the standard in contrast to 
application level, as they are not expected to be invoked as an application.
However, setting the level to standard in the menu of the graphical user interface
stills allows their execution.
When extending the abstract super class it is necessary to annotate the
class with @ALDDerivedClass in order to allow Alida's dataIO mechanism to find the derived class
in the automatically generated user interface.
This holds for other parameter types as well.
More specifically, if an instance of a class is to be supplied in an automatically 
generated user interface as a value for a parameter of one of its super classes,
Alida requires the annotation @ALDDerivedClass.

The ApplyToMatrix operator also demonstrates supplemental parameters.
This supplementals, e.g., control debugging output or returning of intermediate results.
For demo purposes we declare a supplemental input parameter returnElapsedTime.
If it is set to true the operator will return the elapsed time in a second
supplemental parameter with direction output.

Again, the operation is implemented in the operate method and the remainder of the
class supplies getter and setter methods for convenience.
The operate method give also an example of the invocation of an operator on the
programming level.
In this case, an instance of the operator is already passed as a parameter.
Its parameters are set, in this case each 1D array to be summarized in turn.
Upon return from the method runOp the results may be retrieved from the operator object,
in this example with the getSummary method.
Besides getter and setter methods as implemented in each operator
Alida provides also a generic get and set methods applicable to
all parameters of an operator.
Note, that the operator is not invoked by its operate method, but via
the runOp method implemented the base class ALDOperator.
This methods validates the parameters before invocation of operate.
Furthermore, it take all necessary measures for Alida's processing
history which automatically logs
all manipulative actions on the data and corresponding parameter settings. 

2.2 Invocation via a graphical user interface

If the graphical interface is still running just select our new operator
and begin to configure it.
For the parameter summarizing operator you have a choice of all operators extending
the abstract operator ALDSummarizeArrayOp.
All which is necessary on the implementation side is proper annotation of the extending
classes with @ALDDerivedClass.
As the selected operator may have its own parameters you may want to configure it.
In our example this is not necessary as the input array is, of course, supplied
by the ApplyToMatrix operator.
Do not forget to input your data before hitting the run button.
After return, again a result window give you the results of the operation.
Note, if you did not tick Return elapsed time" this window will show zero
for the time elapsed as the operator has not been request to stop the time.


2.3 Invocation via command line

When invoking the ApplyToMatrix operator from command line
we have to handle derived classes as value for parameters.
In the graphical user interface Alida features a combo box where
we may choose from.
In the command line interface Alida allows to prefix the value of a parameter
with a derived class to be passed to the operator.
This is necessary as Alida as, of course, no way to itself
decide if and which derived class is to be used.
Alida's syntax is to enclose the class name in a dollar sign and a colon.
As evident in the following example, abbreviations are of the fully
qualified class name are accepted as long as they are unambiguous.

  java de.unihalle.informatik.Alida.tools.ALDOpRunner Apply \
	matrix='[[1,2,3],[4,5,6]]' \
	summarizeMode=ROW \
	summarizeOp='$ALDArrayMean:{}' \
	summaries=-

results in
	summaries = [2.0,5.0]


ALDOpRunner may be persuaded to show all operators derived from ALDSummarizeArrayOp
and known within the user interface if we enter an invalid class name:

    java de.unihalle.informatik.Alida.tools.ALDOpRunner \
	Apply matrix='[[1,2,3],[4,5,6]]' \
	summarizeMode=ROW summarizeOp='$dd:{}' \
	summaries=-

yields

ALDStandardizedDataIOCmdline::readData found 0 derived classes matching <dd>
      derived classes available:
	de.unihalle.informatik.Alida.demo.ALDArrayMean
	de.unihalle.informatik.Alida.demo.ALDArrayMin
	de.unihalle.informatik.Alida.demo.ALDArraySum
ERROR: reading parameter <summarizeOp> returns null


Supplemental parameters are handled like other parameters

java de.unihalle.informatik.Alida.tools.ALDOpRunner Apply \
	matrix='[[1,2,3],[4,5,6]]' \
	summarizeMode=COLUMN \
	summarizeOp='$ALDArrayMin:{}' \
	summaries=- \
	returnElapsedTime=true \
	elapsedTime=-

gives
	summaries = [1.0,2.0,3.0]
	elapsedTime = 4



3. Adding more data types as parameters

Alida provides automatic IO of primitive data types, enumerations, arrays, collections,
and operators.
In addition so called parameterized classes are supported.
Any Java class may be declared to be a parameterized class in Alida
by annotating the class @ALDParametrizedClass as shown in the
class ExperimentalData.
All member variables to be known to and handled by Alida's user interface
simply need to be annotated with @ALDClassParameter.

Here we implement a toy version of experimental data ExperimentalData.
A complete experiment consists of a number of independent repetitions of
sub experiments. 
In each of these the same features (measurements) are recorded.
The measurements a represented in 
a 2D array of Doubles, where each column represents
one sub experiment and the rows the distinct features.
The measurements may be normalized which is indicated by the
normalized member variable.

The class is annotated by @ALDParametrizedClass, and
and all members to be handle in Alida'a user interfaces are
to be annotated with @ALDParametrizedClass.
The label field has the same semantics as for parameters of operators.
These annotations are the only implementational overhead
to allow Alida to automatically generate user interfaces
where the parameterized class acts a a parameter.
This is shown below for a simple normalizing operator NormalizeExperimentalDataOp
which takes experimental data as input an returns a new instance
of ExperimentalData which contains normalized data.


This mechanism applies in a recursive fashion, i.e. a parameterized class may
(recursively) contain a member variable which itself is a parametrized class.
Likewise, an operator acting as a parameter of another operator
may in turn have a parameter of type ALDOperator.

3.1 Invocation via a graphical user interface

Invoking and configuring NormalizeExperimentalDataOp from the graphical user interface
shows as the only required parameter the experimental data.
This parameterized class can be configured in a separate  window
very similar to to configuration of operators.
Likewise the resulting normalized experimental data
may be inspected in their own window.

Obviously this is a toy example, as we would not expect the measurements to
be entered manually, but rather stored and read from file in a specialized format.
This is one of the rare cases where 
custom data IO provider need to be implemented, in this
case for ExperimentalData.


3.2 Invocation via command line

Again, invocation from command line is provided by Alida in an automatic
way with no further implementational overhead.
The syntax for parameterized classes es a comma separated list of name=value pairs
enclosed in curly brackets where name refers to annotated member variables of
the parameterized class.

    java de.unihalle.informatik.Alida.tools.ALDOpRunner NormalizeExperimentalDataOp \
	experiment='{data=[[1,2,3],[2,2,2],[100,103,110]],description="Demo experiment"}' \
	result=-
yields
	result = { normalized = true , description = "Demo experiment" (Normalized) , data = [[-1.0,0.0,1.0],[0.0,0.0,0.0],[-4.333333333333329,-1.3333333333333286,5.666666666666671]] }


If a class derived from ExperimentalData was to be supplied to the operator,
the curly brackets can be prefixed by a derive class definition starting with a dollar sign
and ending with a colon as shown for the summarizing operators above.
